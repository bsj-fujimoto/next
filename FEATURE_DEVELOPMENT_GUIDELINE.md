# 機能開発ガイドライン

ユーザーが機能の実装を指示したら以下のステップに分けてタスクを進めてください。

---

## 📋 基本原則

以下の原則は全てのステップで適用されます：

- ✅ **アウトプットの一貫性**: 全てのステップのアウトプットは、そのタスクにおけるインプットと対となる成果物となるようにすること
- 🌿 **ブランチ戦略**: 
  - 作業は必ず現在のブランチから適切な`feature/xxx/develop`ブランチを作成し、これをベースに進めること
  - 全てのステップでは別のブランチ(`feature/xxx/step-xxx`)を作成して進ること
- 📝 **コミットとPR**: 
  - ステップ毎に適切なコミットメッセージでコミットしPRを作成すること
  - PRは必ず一つ前の工程のブランチに向けて作成すること
- ⏩ **進行方針**: 全てのステップを完走するまでPRのレビュー結果を待たずに進めること
- 📢 **完了報告**: 全行程が終わったらユーザーに報告し、次の指示を待つこと

---

## 🔄 ステップ概要

```
Step 1: 計画を立てる
   ↓
Step 2: テスト計画を立てる
   ↓
Step 3: テストコードを実装する
   ↓
Step 4: 機能を実装する
   ↓
Step 5: テストコードを実行し、結果を確認する
   ↓
Step 6: ガイドライン遵守チェックを行いリファクタリングを計画する
   ↓
Step 7: リファクタリングを実施する
   ↓
Step 8: 全てのテストを再実行し、結果を確認する
   ↓
Step 9: 最終的なセルフレビューを行い、PRを作成する
```

---

## Step 1: 計画を立てる

### 📥 インプット
- その機能開発に関係するユーザーの指示内容の全て（過去の履歴全てではない）

### 📤 アウトプット
- ユーザーの指示内容を含む、計画を記載したMarkdownファイル

### 📋 手順
1. ユーザーの指示内容を確認する
2. 機能開発の背景情報や曖昧な点、詳細に詰めるべき点が残っている場合は事前にユーザーにヒアリングを行う
3. 最終的にユーザーが求める機能や結果を明確にする
4. 計画をMarkdownファイルに記載する

---

## Step 2: テスト駆動開発で進めるためのテスト計画を立てる

### 📥 インプット
- Step 1のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 機能のユースケースとそれに対応するテストケースを記載したMarkdownファイル

### 📋 手順
1. 一番外側のユースケースをテストケースに分解する
2. それぞれのテストケースを実装する計画を立てる
3. テスト計画をMarkdownファイルに記載する

> **注意**: 今後の機能開発を進めていく過程でコンポーネント分離等が発生すると思うが、それらは明確になってから改めてその粒度でテスト駆動開発を進める。

---

## Step 3: テストコードを実装する

### 📥 インプット
- Step 2のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- テストコードを実装したファイル
- PRにはテストを実行した結果のエビデンスを添付すること

### 📋 手順
1. Step 2のテスト計画に基づいてテストコードを実装する
2. テストを実行し、エビデンスを取得する
3. 以下を確認する：
   - ✅ テストケースが全て失敗すること
   - ✅ テストケースがStep 2のテスト計画で立てたものと一致していること

---

## Step 4: 機能を実装する

### 📥 インプット
- Step 3のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 機能を実装したファイル
- ガイドラインの遵守状況を記載したMarkdownファイル

### 📋 手順
1. 実装ガイドラインを参照して実装を進める
   - 詳細なコンポーネント分離やそのレベルのテストコードの追加はここでは行わなくてよい
2. npmパッケージを導入する際の注意：
   - 出来るだけ最新のバージョンを導入する
   - `npm audit`の結果に警告があればアップデートを検討する
   - 特にcritical warningがあれば必ず修正し、可能な限りベストな状態を目指す
3. ガイドラインを元にセルフレビューを行い、ガイドライン遵守状況をMarkdownに纏めてPRに添付する
   - この段階では遵守していなくても良い
   - 後のステップでリファクタリングをするための情報を残す事が目的

---

## Step 5: テストコードを実行し、結果を確認する

### 📥 インプット
- Step 4のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- テストコードを実行した結果のエビデンス

### 📋 手順
1. テストコードを実行する
2. 最初に立てたユースケースレベルのテストが全て成功することを確認する

---

## Step 6: ガイドライン遵守チェックを行いリファクタリングを計画する

### 📥 インプット
- Step 4と5のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- リファクタリング計画を記載したMarkdownファイル

### 📋 手順
1. ガイドラインに遵守出来ていない部分を列挙する
2. それぞれを解消するためのリファクタリング案を可能な限り詳細にMarkdownに記載する
3. Markdownの構造：
   - **最初に概要**: 遵守出来ていない部分の一覧を記載し、それぞれの詳細な解説の章に内部リンクする
   - この一覧が次のステップでのコミットの単位となる
   - **詳細な解説の章**: 
     - どのファイルのどこがどのガイドラインに違反しているか
     - どの部分をどのように修正するかを対比して記載する
     - 同様の部分は方針が分かるように一例を挙げるだけで良い

### ⚠️ 重要な注意事項
- **同じ違反は同じコミットで修正する**: 差分を見れば同様の問題であること、同様の修正を行ったことを分かりやすくするために重要
- **コンポーネント分割の例外**: コンポーネント分割は一つひとつが重い作業となるので、同様のガイドライン違反だとしてもコンポーネント単位でコミットを分けるようにタスク分解する

> **目標**: この計画書はユーザーと次のステップを実行する時のAIエージェントにとって理解しやすい形式であることが正解となります。

---

## Step 7: リファクタリングを実施する

### 📥 インプット
- Step 6のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- リファクタリングを実施したファイル

### 📋 手順
1. Step 6のリファクタリング計画に従ってリファクタリングを実施する

2. **コンポーネント分割をする場合**:
   - そのコンポーネントの責務を明確にする
   - そのコンポーネントが持つPropsやStateを明確にする
   - そのコンポーネントが持つロジックを明確にする
   - そのコンポーネントに対してのテストケースの設計も行い、それらをドキュメント化する
   - テスト駆動開発として以下を繰り返す：
     - テストコードの実装
     - テスト失敗の確認
     - コンポーネント実装
     - ガイドライン遵守の確認
     - テスト成功
   - それが終わったらそのコンポーネントを利用すべき場所に適用する

3. **リファクタリング後の確認**:
   - リファクタリングが終わったらガイドラインに沿っているかを改めてセルフレビューする
   - 修正する箇所がなくなるまでこれを繰り返す

4. 最終的にガイドライン遵守状況をMarkdownに纏めてPRに添付する

---

## Step 8: 全てのテストを再実行し、結果を確認する

### 📥 インプット
- Step 7のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 全てのテストを再実行した結果のエビデンス

### 📋 手順
1. 全てのテストを再実行する
2. 全てのテストが成功することを確認する

---

## Step 9: 最終的なセルフレビューを行い、PRを作成する

### 📥 インプット
- Step 8のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 最終的なセルフレビュー結果を記載したMarkdownファイル

### 📋 手順
1. 最終的なセルフレビューを実施する
2. `npm audit`の結果も含めて、やれるだけのことはやったと言える成果物を報告する
