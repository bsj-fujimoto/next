# 機能開発ガイドライン

ユーザーが機能の実装を指示したら以下のステップに分けてタスクを進めてください。

---

## 📋 基本原則

以下の原則は全てのステップで適用されます：

- ✅ **アウトプットの一貫性**: 全てのステップのアウトプットは、そのタスクにおけるインプットと対となる成果物となるようにすること
- 🌿 **ブランチ戦略**: 
  - 作業は必ず現在のブランチから適切な`feature/xxx/develop`ブランチを作成し、これをベースに進めること
  - 全てのステップでは別のブランチ(`feature/xxx/step-xxx`)を作成して進ること
- 📝 **コミットとPR**: 
  - ステップ毎に適切なコミットメッセージでコミットしPRを作成すること
  - PRは必ず一つ前の工程のブランチに向けて作成すること
- ⏩ **進行方針**: 全てのステップを完走するまでPRのレビュー結果を待たずに進めること
- 📢 **完了報告**: 全行程が終わったらユーザーに報告し、次の指示を待つこと

---

## 🔄 ステップ概要

```
Step 1: 計画を立てる
   ↓
Step 2: テスト計画を立てる
   ↓
Step 3: テストコードを実装する
   ↓
Step 4: 機能を実装する
   ↓
Step 5: テストコードを実行し、結果を確認する
   ↓
Step 6: ガイドライン遵守チェックを行いリファクタリングを計画する
   ↓
Step 7: リファクタリングを実施する
   ↓
Step 8: 全てのテストを再実行し、結果を確認する
   ↓
Step 9: 最終的なセルフレビューを行い、PRを作成する
```

---

## Step 1: 計画を立てる

### 📥 インプット
- その機能開発に関係するユーザーの指示内容の全て（過去の履歴全てではない）

### 📤 アウトプット
- ユーザーの指示内容を含む、計画を記載したMarkdownファイル

### 📋 手順
1. ユーザーの指示内容を確認する
2. 機能開発の背景情報や曖昧な点、詳細に詰めるべき点が残っている場合は事前にユーザーにヒアリングを行う
3. 最終的にユーザーが求める機能や結果を明確にする
4. **非機能要件を確認する**:
   - パフォーマンス要件（レスポンス時間、同時接続数など）
   - アクセシビリティ要件（WCAG準拠レベルなど）
   - セキュリティ要件（認証、認可、データ保護など）
   - ブラウザサポート範囲
   - モバイル対応の必要性
5. **依存関係を確認する**:
   - 既存のコンポーネントやライブラリの利用可否
   - 新しいnpmパッケージの導入が必要か
   - APIエンドポイントの変更が必要か
6. **エッジケースとエラーハンドリングを検討する**:
   - 想定されるエラーケース
   - フォールバック処理の必要性
   - ユーザーフィードバックの方法
7. 計画をMarkdownファイルに記載する

---

## Step 2: テスト駆動開発で進めるためのテスト計画を立てる

### 📥 インプット
- Step 1のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 機能のユースケースとそれに対応するテストケースを記載したMarkdownファイル

### 📋 手順
1. 一番外側のユースケースをテストケースに分解する
2. **テストの種類を明確にする**:
   - ユニットテスト: 個別の関数やコンポーネントのテスト
   - 統合テスト: 複数のコンポーネントの連携テスト
   - E2Eテスト: ユーザーシナリオ全体のテスト
   - ビジュアルリグレッションテスト: UIの見た目の変更検知
3. **エッジケースとエラーケースを含める**:
   - 異常系のテストケース
   - 境界値のテストケース
   - エラーハンドリングのテストケース
4. **アクセシビリティテストを含める**:
   - キーボードナビゲーション
   - スクリーンリーダー対応
   - ARIA属性の適切な使用
5. それぞれのテストケースを実装する計画を立てる
6. テスト計画をMarkdownファイルに記載する

> **注意**: 今後の機能開発を進めていく過程でコンポーネント分離等が発生すると思うが、それらは明確になってから改めてその粒度でテスト駆動開発を進める。

---

## Step 3: テストコードを実装する

### 📥 インプット
- Step 2のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- テストコードを実装したファイル
- PRにはテストを実行した結果のエビデンスを添付すること

### 📋 手順
1. Step 2のテスト計画に基づいてテストコードを実装する
2. **テストの種類に応じた実装**:
   - ユニットテスト: Jest + React Testing Library
   - E2Eテスト: Playwright
   - ビジュアルリグレッションテスト: Playwrightのスクリーンショット機能
3. **テストの品質を確保**:
   - テストの独立性（他のテストに依存しない）
   - テストの再現性（同じ結果が得られる）
   - テストの明確性（何をテストしているか明確）
4. **テストを実行し、エビデンスを取得する**:
   - E2Eテスト（Playwright）の場合：
     - `playwright.config.ts`で`video: 'on'`または`video: 'retain-on-failure'`を設定し、テスト実行時の動画を記録する
       ```typescript
       // playwright.config.ts の例
       export default defineConfig({
         use: {
           video: 'retain-on-failure', // 失敗時のみ動画を保持（推奨）
           // または video: 'on', // 全てのテストで動画を記録
         },
       });
       ```
   - 重要なテストケースでは`await page.screenshot({ path: 'screenshot.png' })`を使用してスクリーンショットを取得する
   - テスト実行後、`test-results/`ディレクトリに動画（`.webm`形式）とスクリーンショットが保存される
   - **PRには必ずテストエビデンスを添付する**:
     - テストが成功した場合は、成功を示すスクリーンショットやテスト結果のサマリーを添付
     - テストが失敗した場合は、失敗を示すスクリーンショット、動画、エラーログを添付
     - `test-results/`ディレクトリの内容をGitHubに添付する（またはGitHub Actionsを使用している場合は自動的にアップロードされる）
   - HTMLレポート（`playwright-report/index.html`）も生成され、ブラウザで確認できる
   - ユニットテスト（Jest）の場合：
     - テスト結果のサマリー（`npm test -- --coverage`の出力など）をスクリーンショットまたはテキストファイルとして保存
     - カバレッジレポート（`coverage/`ディレクトリ）を生成し、PRに添付する
     - カバレッジレポートのHTMLファイル（`coverage/lcov-report/index.html`）をスクリーンショットとして保存
6. **Dropdownやポップアップ、Toastなどの前面表示テスト**:
   - Dropdown、ポップアップ、Toastなど、一時的に前面に表示されるべきコンポーネントは、他の要素より前面に表示されることをテストする
   - z-indexの設定が適切であることを確認する
   - 他の要素に隠れていないことを視覚的に確認する（スクリーンショットで確認）
7. **レイアウトの確認**:
   - 実装後は必ずスクリーンショットを取得してレイアウトの崩れがないか確認する
   - レイアウトの崩れやz-indexの問題があれば修正する
   - スクリーンショットでの確認をテストケースに含める
8. 以下を確認する：
   - ✅ テストケースが全て失敗すること
   - ✅ テストケースがStep 2のテスト計画で立てたものと一致していること
   - ✅ テストコードがガイドラインに準拠していること
   - ✅ エビデンス（スクリーンショット、動画、テスト結果）が適切に記録されていること
   - ✅ Dropdownやポップアップが他の要素より前面に表示されることを確認したこと
   - ✅ コンソールエラーがないことを確認したこと
   - ✅ レイアウトの崩れがないことをスクリーンショットで確認したこと

---

## Step 4: 機能を実装する

### 📥 インプット
- Step 3のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 機能を実装したファイル
- ガイドラインの遵守状況を記載したMarkdownファイル

### 📋 手順
1. **実装前に既存コンポーネントの確認**:
   - 既存のコンポーネントやライブラリで実装できないかを確認する
   - 同様の機能を持つコンポーネントが存在する場合は、共通化や再利用を検討する
   - 既存コンポーネントを拡張する形で実装できないかを検討する
2. 実装ガイドラインを参照して実装を進める
   - 詳細なコンポーネント分離やそのレベルのテストコードの追加はここでは行わなくてよい
3. **実装時の注意事項**:
   - エラーハンドリングを適切に実装する
   - ローディング状態を適切に表示する
   - アクセシビリティ属性を適切に設定する（aria-label, role, tabIndexなど）
   - セキュリティベストプラクティスに従う（XSS対策、CSRF対策など）
3. npmパッケージを導入する際の注意：
   - 出来るだけ最新のバージョンを導入する
   - `npm audit`の結果に警告があればアップデートを検討する
   - 特にcritical warningがあれば必ず修正し、可能な限りベストな状態を目指す
   - **ライセンスを確認する**: MIT、Apache-2.0などの互換性のあるライセンスか確認
   - **バンドルサイズを確認する**: 大きなパッケージの導入は慎重に検討
4. **環境変数の管理**:
   - 環境変数が必要な場合は`.env.example`に記載
   - 機密情報は環境変数で管理し、コードに直接記載しない
5. **ドキュメントの作成**:
   - 新規コンポーネントの場合はMarkdownドキュメントを作成
   - **コンポーネントリストに必ず追加する**（`componentList.tsx`に追加）
   - `ComponentPreview.tsx`の`componentMap`に追加
   - `ComponentPreview.tsx`の`defaultProps`に追加（プレビュー用）
   - `page.tsx`の`SelectedComponent`型に追加
   - 使用例とバリエーションを記載
6. ガイドラインを元にセルフレビューを行い、ガイドライン遵守状況をMarkdownに纏めてPRに添付する
   - この段階では遵守していなくても良い
   - 後のステップでリファクタリングをするための情報を残す事が目的

---

## Step 5: テストコードを実行し、結果を確認する

### 📥 インプット
- Step 4のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- テストコードを実行した結果のエビデンス
- PRに添付するスクリーンショット、動画、テスト結果レポート

### 📋 手順
1. **テストコードを実行する**:
   - E2Eテスト: `npm run test:e2e`を実行し、Playwrightの動画とスクリーンショットを記録
   - ユニットテスト: `npm test -- --coverage`を実行し、カバレッジレポートを生成
2. **テスト結果の詳細確認**:
   - 最初に立てたユースケースレベルのテストが全て成功することを確認する
   - テストの実行時間を記録する（パフォーマンスベースラインの確立）
   - テストカバレッジを確認する（可能な限り80%以上を目指す）
3. **失敗したテストの分析**:
   - 失敗の原因を明確にする
   - 実装の問題か、テストの問題かを判断する
   - 必要に応じてテストを修正する
   - 失敗したテストのスクリーンショットと動画を確認する
4. **ビジュアルリグレッションテストの確認**:
   - スクリーンショットを確認し、意図しないUI変更がないか確認
   - 重要な画面遷移や操作の動画を確認する
5. **エビデンスの整理とPRへの添付**:
   - E2Eテストの動画とスクリーンショットを`test-results/`から取得
   - ユニットテストのカバレッジレポートを取得
   - テスト結果のサマリーをMarkdown形式で作成
   - **PRの説明欄またはコメントに必ずエビデンスを添付する**:
     - テストが成功した場合は、成功を示すスクリーンショットやテスト結果のサマリーを添付
     - テストが失敗した場合は、失敗を示すスクリーンショット、動画、エラーログを添付

---

## Step 6: ガイドライン遵守チェックを行いリファクタリングを計画する

### 📥 インプット
- Step 4と5のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- リファクタリング計画を記載したMarkdownファイル

### 📋 手順
1. ガイドラインに遵守出来ていない部分を列挙する
2. **チェックリストを使用**:
   - コンポーネント設計（単一責任、適切な分割）
   - Hooksの使用（適切な依存配列、メモ化）
   - パフォーマンス最適化（memo, useMemo, useCallback）
   - 型安全性（any型の排除、適切な型定義）
   - 状態管理（適切な状態の配置）
   - エラーハンドリング
   - アクセシビリティ
   - セキュリティ
3. それぞれを解消するためのリファクタリング案を可能な限り詳細にMarkdownに記載する
4. Markdownの構造：
   - **最初に概要**: 遵守出来ていない部分の一覧を記載し、それぞれの詳細な解説の章に内部リンクする
   - この一覧が次のステップでのコミットの単位となる
   - **優先順位の記載**: 重要度や影響範囲に基づいて優先順位を付ける
   - **詳細な解説の章**: 
     - どのファイルのどこがどのガイドラインに違反しているか
     - どの部分をどのように修正するかを対比して記載する
     - 同様の部分は方針が分かるように一例を挙げるだけで良い

### ⚠️ 重要な注意事項
- **同じ違反は同じコミットで修正する**: 差分を見れば同様の問題であること、同様の修正を行ったことを分かりやすくするために重要
- **コンポーネント分割の例外**: コンポーネント分割は一つひとつが重い作業となるので、同様のガイドライン違反だとしてもコンポーネント単位でコミットを分けるようにタスク分解する

> **目標**: この計画書はユーザーと次のステップを実行する時のAIエージェントにとって理解しやすい形式であることが正解となります。

---

## Step 7: リファクタリングを実施する

### 📥 インプット
- Step 6のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- リファクタリングを実施したファイル

### 📋 手順
1. Step 6のリファクタリング計画に従ってリファクタリングを実施する
2. **リファクタリング時の注意事項**:
   - 一度に一つの変更に集中する（複数の変更を同時に行わない）
   - 各変更後にテストを実行して動作確認する
   - 変更の影響範囲を最小限に抑える

3. **コンポーネント分割をする場合**:
   - そのコンポーネントの責務を明確にする
   - そのコンポーネントが持つPropsやStateを明確にする
   - そのコンポーネントが持つロジックを明確にする
   - そのコンポーネントに対してのテストケースの設計も行い、それらをドキュメント化する
   - テスト駆動開発として以下を繰り返す：
     - テストコードの実装
     - テスト失敗の確認
     - コンポーネント実装
     - ガイドライン遵守の確認
     - テスト成功
   - それが終わったらそのコンポーネントを利用すべき場所に適用する
   - コンポーネントリストにも掲載する
   - **既存のテストが壊れていないか確認する**

4. **リファクタリング後の確認**:
   - リファクタリングが終わったらガイドラインに沿っているかを改めてセルフレビューする
   - 修正する箇所がなくなるまでこれを繰り返す
   - **パフォーマンスへの影響を確認する**（必要に応じてパフォーマンステストを実行）

5. 最終的にガイドライン遵守状況をMarkdownに纏めてPRに添付する

---

## Step 8: 全てのテストを再実行し、結果を確認する

### 📥 インプット
- Step 7のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 全てのテストを再実行した結果のエビデンス
- PRに添付するスクリーンショット、動画、テスト結果レポート

### 📋 手順
1. **全てのテストを再実行する**:
   - ユニットテスト（`npm test -- --coverage`）
   - E2Eテスト（`npm run test:e2e`）- Playwrightの動画とスクリーンショットを記録
   - ビジュアルリグレッションテスト（必要に応じて）
2. **テスト結果の詳細確認**:
   - 全てのテストが成功することを確認する
   - テストの実行時間を記録し、以前の結果と比較する
   - テストカバレッジを確認し、リファクタリング前と比較する
3. **パフォーマンステストの実行**（必要に応じて）:
   - Lighthouseスコアの確認（スクリーンショットを取得）
   - バンドルサイズの確認（`npm run build`の出力を確認）
   - 初回ロード時間の確認
4. **アクセシビリティテストの実行**（必要に応じて）:
   - axe DevToolsなどのツールを使用（スクリーンショットを取得）
   - キーボードナビゲーションの確認（動画を記録）
   - スクリーンリーダーの確認
5. **エビデンスの整理とPRへの添付**:
   - E2Eテストの動画とスクリーンショットを`test-results/`から取得
   - ユニットテストのカバレッジレポートを取得
   - パフォーマンステストとアクセシビリティテストの結果をスクリーンショットとして保存
   - テスト結果のサマリーをMarkdown形式で作成し、リファクタリング前後の比較を含める
   - PRの説明欄またはコメントにエビデンスを添付する

---

## Step 9: 最終的なセルフレビューを行い、PRを作成する

### 📥 インプット
- Step 8のアウトプット（gitの差分やPRの内容で確認出来るはず）

### 📤 アウトプット
- 最終的なセルフレビュー結果を記載したMarkdownファイル

### 📋 手順
1. **コードレビューの観点でセルフレビューを実施**:
   - コードの可読性と保守性
   - パフォーマンスへの影響
   - セキュリティ上の問題
   - アクセシビリティの確保
   - エラーハンドリングの適切性
   - テストの十分性
2. **チェックリストの確認**:
   - ✅ 全てのテストが成功している
   - ✅ ガイドラインに準拠している
   - ✅ ドキュメントが更新されている
   - ✅ コンポーネントリストに追加されている（新規コンポーネントの場合）
   - ✅ エラーハンドリングが適切に実装されている
   - ✅ アクセシビリティ属性が適切に設定されている
   - ✅ パフォーマンスへの悪影響がない
   - ✅ セキュリティ上の問題がない
3. **`npm audit`の結果確認**:
   - critical warningがないことを確認
   - high warningも可能な限り修正
   - 修正できない場合は理由を記載
4. **ビルドの確認**:
   - `npm run build`が成功することを確認
   - ビルドエラーや警告がないことを確認
   - バンドルサイズが適切であることを確認
5. **最終確認**:
   - やれるだけのことはやったと言える成果物を報告する
   - PRの説明に以下を含める：
     - 実装内容の概要
     - テスト結果のサマリー
     - ガイドライン遵守状況
     - 注意事項や既知の問題

---

## 📚 参考チェックリスト

### パフォーマンス最適化チェックリスト

実装時に確認すべき項目：

- [ ] 不要な再レンダリングがないか（React.memo, useMemo, useCallbackの適切な使用）
- [ ] 画像の最適化（Next.js Imageコンポーネントの使用）
- [ ] コード分割の適切な実装（動的インポート）
- [ ] バンドルサイズの確認
- [ ] 初回ロード時間の確認
- [ ] メモリリークの確認

### アクセシビリティチェックリスト

実装時に確認すべき項目：

- [ ] 適切なARIA属性の使用（aria-label, aria-describedby, roleなど）
- [ ] キーボードナビゲーションのサポート
- [ ] フォーカス管理の適切な実装
- [ ] 色のコントラスト比の確認（WCAG AA以上）
- [ ] スクリーンリーダーでの動作確認
- [ ] セマンティックHTMLの使用

### セキュリティチェックリスト

実装時に確認すべき項目：

- [ ] XSS対策（dangerouslySetInnerHTMLの使用を最小限に）
- [ ] CSRF対策（API呼び出し時の適切な実装）
- [ ] 認証・認可の適切な実装
- [ ] 機密情報の適切な管理（環境変数の使用）
- [ ] 依存関係の脆弱性確認（npm audit）
- [ ] 入力値のバリデーション
